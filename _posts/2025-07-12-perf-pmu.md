---
title: "Perf and PMU"
excerpt_separator: "<!--more-->"
categories:
  - Tech
tags:
  - Performance
  - ArmV8-A
  - Yocto
---

# Perf and PMU
 - A walkthrough on PMU and it's usabilty by leveraging Perf.

## Introduction

### What is the motivation?

I wanna get the cpu metrics in real time. Understanding CPU and getting insights about CPU during run time regarding various metrics and it's usage upon certain application is a important form of knowledge to optimize the system for that specific target.

I was curious know to is there any specific feature in modern processor to track the CPU metrics during run time without much overhead. This leads to the exploration of PMU (Performance Monitoring Unit), which is a sub system (bunch of hardware counters) use to monitor number of CPU events. So then my next question is, how can I enable and use it? One way would be accessing the PMU hardware directly using system control coprocessor instructions. Since the target is running on Linux platform I was pretty sure that there might be some drivers already exist to leverage this hardware functionality. Hence, there is Linux PMU driver exist and it offers numerous *Syscall* to access the PMU functionality. https://web.eece.maine.edu/~vweaver/projects/perf_events/perf_event_open.html

**Perf**, is a another command line tool in Linux which actually uses PMU under the hood to get the CPU metrics. PMU is supported in various platforms such as x_86, Arm and so on.
More about perf tool needs to added
Perf offers various sub commands to collect information about wide collections of hardware events using PMU. As per the ArmV8-A architecuture, the PMU can record more than XXX number of events. However, the number of hardware counters are limited and thereby if we need to record events more than the number of hardware counters then the system does multiplexing.

### PMU

The basic blocks of PMU contains a 64-bit cycle counter, an optional 64-bit instruction counter and a number of 64 bit or 32 bit event counters. The width of the event counters is based on what version of PMU extension that specific chip's implementation based. The number of event counters that architecture supports up to 31 and it's ultimately it's up to the implementation. As part of the PMU extension implementation it is mandatory to include the *System Register Interface*. The operating system or even the application software (with OS permission) can use this registers to access the counters to monitor its performance.

*Time as mesured by the Performance Monitors cycle counter* : The cycle counter of PMU is increment from the hardware processor clock and it's up to the implementation to establish the relationship between the recorded count and the passage of real time. As per the architecture, to keep the implementation, validation, and performance overhead costs low, it allows reasonable degree of inaccuracy in the counts and the logic in detecting the overflow, but it recommends certain guidelines to follow.

The mechanisms available for controlling the PMU event and cycle counters include: *Enabling PMU counters, Freezing PMU counters, Resetting PMU counters, and Prohibiting counting*.

The most commonly used PMU events are :

Other metrics can be calculated from the above stats. for example,

## Setup

Shows how to get CPU metrics using PMU with Perf in Raspberry Pi 4B

The various steps involved in setting the kernel for raspberry 4b to use Perf

1. Enable PMU in Linux kernel and install Perf using Yocto
  > For this project, [meta-raspberrypi](https://git.yoctoproject.org/meta-raspberrypi/log/?h=dunfell) layer has been used as the BSP.

  The **OE-Core** by default provides a *bitbake* recipe for enabling Arm PMU support for Kernel and installing Perf.

  **Example**

  ```
  # add the following line to 'meta-raspberrypi/recipes-core/images/rpi-test-image.bb'
  # Disclaimer: A good yocto pratice is, any custom change required for the BSP specific to the project should be moved to separate layer and let it overrides the default configuration. For simplicity, here it making changes on the actual bsp layer itself.

  IMAGE_INSTALL += " perf"

  or

  IMAGE_INSTALL:append = " perf"

  ```

  To verify it installed correctly on the system

  ```
  # check the perf is installed
   > perf -v
   > perf version 5.4.72

  # check the PMU events are shown in sys dir
  >  ls /sys/bus/event_source/devices/armv8_cortex_a72/events/
  br_mis_pred         cpu_cycles          l1d_cache           l1i_cache_refill    mem_access
  br_pred             exc_return          l1d_cache_refill    l1i_tlb_refill      memory_error
  bus_access          exc_taken           l1d_cache_wb        l2d_cache           sw_incr
  bus_cycles          inst_retired        l1d_tlb_refill      l2d_cache_refill    ttbr_write_retired cid_write_retired   inst_spec           l1i_cache           l2d_cache_wb

  Note: This is a subset of PMU events supported by Armv8-A architecture

  # check the kernel logs to verify the hw perf events are enabled
  > dmesg | grep -i pmu
  > [    0.875818] hw perfevents: enabled with armv8_cortex_a72 PMU driver, 7 counters available
  ```
  From the above verification, it is clear that PMU supports only up to 7 counters. i.e, one cycle counter and 6 event counters.


## Performance Workflow Analysis

## Conclusion